**HR_SYS_1.0实践学习笔记**  


----------


**一、Java封装**  
1.封装的概念：封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制  
2.封装的目的：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.良好的封装能够减少耦合  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.类内部的结构可以自由修改  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.对成员变量进行更精确的控制  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d.隐藏信息，实现代码细节  
3.封装如何实现：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.修改成员属性的可见性来限制对属性的访问（一般限制为private）  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.对每个成员属性提供对外的公共方法访问，也就是创建getter和setter方法  
  
**二、逻辑删除和物理删除**  
1.逻辑删除：逻辑删除的本质是修改操作，在表中将对应的是否删除标识（is_delete）或者说是状态字段（status）做修改操作。在逻辑上数据是被删除的，但数据本身依然存在于数据库中（回收站恢复原理）  
2.物理删除：将对应数据从数据库中删除  
  
**三、数组和链表的区别**  
详情参考<https://www.cnblogs.com/wzb0228/p/11670436.html>  
  
**四、ArrayList**  
1.数组和ArrayList：数组是静态的，数组被初始化之后，数组长度就不能再改变了；而ArrayList是可以动态改变大小的；当我们不知道到底有多少个数据元素的时候，就可使用ArrayList；如果知道数据集合有多少个元素，就用数组  
2.ArrayList用法总结：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.ArrayList是实现List接口的，底层采用数组实现  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.ArrayList实现了Cloneable接口，即覆盖了函数clone()，能被克隆  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输  
2.ArrayList的使用：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.ArrayList的三种构造函数区别：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a-1.ArrayList()：默认构造函数，提供初始容量为10的空列表  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a-2.ArrayList(Collection<? extends E>   c)：构造一个包含指定collection的元素的列表，这些元素是按照该collection的迭代器返回它们的顺序排列的  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a-3.ArrayList(int initialCapacity)：构造一个具有指定初始容量的空列表  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.ArrayList成员方法参见官方文档 
  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：ArrayList类只支持对象类型，不支持基础数据类型。就是说ArrayList对象只能存放对象，不能存放基础数据类型的数据  
  
**五、ArrayList的三种遍历方式及使用区别**  
1.for循环：一般用来处理比较简单的有序的，可预知大小的集合或数组  
  
    for (int i = 0; i < list.size(); i++) {  
      value = list.get(i);  
    }  
      
2.foreach：可用于遍历任何集合或数组，而且操作简单易懂，他唯一的不好就是需要了解集合内部类型  
  
    for (元素类型 ele : list) {  
      value = ele;  
    }  
      
3.iterator：是最强大的，它可以随时修改或者删除集合内部的元素，并且是在不需要知道元素和集合的类型的情况下进行的，当需要对不同的容器实现同样的遍历方式时，迭代器是最好的选择  
Iterator迭代器方式:迭代器是一种模式，它可以使得对于序列类型的数据结构的遍历行为与被遍历的对象分离，即我们无需关心该序列的底层结构是什么样子的。只要拿到这个对象,使用迭代器就可以遍历这个对象的内部  
  
    Iterator iterator = list.iterator();  
    while(iterator.hasNext()) {  
      value = iterator.next();  
    }  
        
详情见<https://www.cnblogs.com/aoguren/p/4771589.html>  
  
**六、ArrayList扩容原理**  
ArrayList是实现了基于动态数组的数据结构,如果没指定数组大小，则申请默认大小为10的数组，当元素个数增加，数组无法存储时，系统会另个申请一个长度为当前长度1.5倍的数组，然后，把之前的数据拷贝到新建的数组  
源码实现原理详情参考<https://www.cnblogs.com/baichunyu/p/12965241.html>  
  
**七、linkedList和ArrayList的区别**  
详情参考<https://zhuanlan.zhihu.com/p/68478784>  
  
**八、关于Scanner类的close()方法的使用**  
Scanner sc = new Scanner(System.in);中的System.in返回一个InputStream类型的对象  
1.InputStream是一个流，在不用的时候需要关闭，如不关闭流，它是很消耗资源的  
2.in是一个final类型，它一旦被初始化就不能改变；所以，不管后面创建多少个Scanner类对象，其实都是返回同一个InputStream流，也就是说，每一次赋给新对象的地址是同一个  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.如果在第一个Scanner类对象使用完毕时close();将会报错java.util.NoSuchElementException  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.解决方式：在Scanner使用的最后才关闭流，这样既不会报错，也不会造成资源的浪费  
  
**九、关于lombok：**  
Lombok是一个基于java的开发包，能通过注解的方式简化java代码，自动生成javabean的getter和setter方法、构造函数等，提高开发人员的开发效率，lombok能够达到的效果就是在源码中不需要写一些通用的方法，但是在编译生成的字节码文件中会自动帮我们生成这些方法  
注意：Lombok无法实现重载形式的各种构造形式！  
  
**十、IDEA设置自定义类和方法的注释模板**  
详情参考<https://blog.csdn.net/xiaoliulang0324/article/details/79030752>
